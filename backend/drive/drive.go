package drive

import (
	"context"
	errs "errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"

	"github.com/liamvdv/sharedHome/backend"
	"google.golang.org/api/drive/v3"
	"google.golang.org/api/googleapi"
)

// We need to have a map which stores the ids of the folders.

// TODO(liamvdv): CreateFile and co recieve a header that was generated by the caller,
// and does not reflect the real fs.FileHeaders. The .Name property is the full
// filepath encrypted.

// https://gist.github.com/TheGU/e6d0ae13f2fa83f3bd8d
// https://console.cloud.google.com/apis/credentials?project=sharedhome

// rootId stores the id of the sharedHome folder. Its child is the root of a mounted filesystem.
var rootId string

func initGlobals(srv *drive.Service) error {
	q := fmt.Sprintf("title = %q and mimeType = 'application/vnd.google-apps.folder'", backend.RemoteFolderName)
	// fetch the sharedHome ID and that of all sub folders.

	r, err := srv.Files.List().Q(q).Do()
	if err != nil {
		return handleDoError(r.Files[0], err) // rethink
	}
	// TODO(liamvdv): should check if parents are root, because user filesystem might contain a folder which equals backend.RemoteFolderName.
	if len(r.Files) != 1 {
		log.Panicf("More than one root folder with name %q.", backend.RemoteFolderName)
	}

	rootId = r.Files[0].Id
	return nil
}

func createFile(ctx context.Context, srv *drive.Service, parentID string, name string, mtime uint64, src io.Reader) error {

	file := &drive.File{
		Name:            name,
		ModifiedTime:    strconv.FormatUint(mtime, 10),
		Parents:         []string{parentID},
		IsAppAuthorized: true,
		// MimeType:         "application/octet-stream", // binary
		// FileExtension:    ".bin",
	}

	// chuck size of media upload should be equal or larger to encryption chuck size / buffer.
	// googleapi.DefaultUploadChunkSize is 10MB, can be any mulpiple of 256kB.
	// TODO(liamvdv): look into Media()s googleapi.MediaOptions
	// googleapi.ContentType
	res, err := srv.Files.
		Create(file).
		Media(src, googleapi.ContentType("application/octet-stream")).
		Context(ctx).
		Do()
	return handleDoError(res, err)
}

// Do executes the "drive.files.insert" call. Exactly one of *File or error will be non-nil.
// Any non-2xx status code is an error. Response headers are in either *File.ServerResponse.Header
// or (if a response was returned at all) in error.(*googleapi.Error).Header.
// Use googleapi.IsNotModified to check whether the returned error was because http.StatusNotModified was returned.
func handleDoError(file *drive.File, err error) error {
	// *googleapi.Error
	// TODO(liamvdv): we have access to headers, dunno how to handle anything.
	var code int
	if file == nil {
		code = err.Code
	} else {
		code = file.ServerResponse.HTTPStatusCode
	}
	if code == http.StatusNotModified {
		return nil
	}
	return nil
}

func getOrCreateFolder(srv *drive.Service, name string, mtime uint64, parentID string) (*drive.File, error) {
	folder, err := getFolder(srv, name, parentID)
	if err == nil {
		return folder, nil
	}

	return createFolder(srv, name, mtime, parentID)
}

// createFolder does not check if folder already exists. use getOrCreateFolder for that.
func createFolder(srv *drive.Service, name string, mtime uint64, parentID string) (*drive.File, error) {
	r, err := srv.Files.
		Create(
			&drive.File{
				Name:         "sharedHome",
				MimeType:     "application/vnd.google-apps.folder",
				ModifiedTime: strconv.FormatUint(mtime, 10),
				Parents:      []string{parentID}}).
		Fields("*").
		Do()
	if err != nil {
		return nil, err
	}
	return r, nil
}

var AmbigousFileErr = errs.New("Remote: two files or folders have the same name.")

func getFolder(srv *drive.Service, name, parentID string) (*drive.File, error) {
	q := fmt.Sprintf("name = %q and mimeType = 'application/vnd.google-apps.folder' and %q in parents", name, parentID)

	r, err := srv.Files.List().Q(q).Fields("*").Do()
	if err != nil {
		return nil, err
	}
	if len(r.Files) != 1 {
		return nil, AmbigousFileErr
	}
	return r.Files[0], nil
}

func (d *Drive) getParent(dp string) string {
	if dp == "" {
		panic("calling getParent with empty dirpath")
	}

	id, found := d.parIDs[dp]
	if found {
		return id
	}
	// if it's not found, query remote to find all missing IDs in this path.
	names := strings.Split(dp, string(os.PathSeparator))[1:] // exclude "" before seperator
	subq := "name = %q" 
	if l := len(names); l > 1 {
		subq = subq + " " + strings.Repeat("or " + subq, l-1)
	}
	q := fmt.Sprintf(subq + " and mimeType = 'application/vnd.google-apps.folder'", names) 
	
}
