package drive

import (
	"context"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"

	"github.com/liamvdv/sharedHome/backend"
	"github.com/liamvdv/sharedHome/errors"
	"github.com/liamvdv/sharedHome/fs"
	"golang.org/x/oauth2/google"
	"google.golang.org/api/drive/v3"
	"google.golang.org/api/googleapi"
)

// TODO(liamvdv): CreateFile and co recieve a header that was generated by the caller,
// and does not reflect the real fs.FileHeaders. The .Name property is the full
// filepath encrypted.

// check if we can set the id of a file on the client...

// https://gist.github.com/TheGU/e6d0ae13f2fa83f3bd8d
// https://console.cloud.google.com/apis/credentials?project=sharedhome

var (
	_ backend.Service = (*Drive)(nil)
)

// Drive implements Service.
type Drive struct {
	srv drive.Service
}

func New() (*Drive, error) {
	const op = errors.Op("backend.drive.New")

	raw, err := os.ReadFile(DriveCredentialsFilepath)
	if err != nil {
		return nil, errors.E(op, err)
	}
	// drive.DriveScope allows full access to google drive of user.
	cfg, err := google.ConfigFromJSON(raw, drive.DriveScope)
	if err != nil {
		return nil, errors.E(op, err)
	}
	client := getClient(cfg)

	srv, err := drive.New(client)
	if err != nil {
		return nil, errors.E(op, err)
	}
	return &Drive{
		srv: *srv,
	}, nil
}

func (d *Drive) CreateFile(ctx context.Context, header fs.FileHeader, src io.Reader) error {
	return nil
}

func (d *Drive) ReadFile(ctx context.Context, header fs.FileHeader, dst io.Writer) error {
	return nil
}

func (d *Drive) UpdateFile(ctx context.Context, header fs.FileHeader, src io.Reader) error {
	return nil
}

func (d *Drive) DeleteFile(ctx context.Context, header fs.FileHeader) error {
	return nil
}

func (d *Drive) RenameFile(ctx context.Context, oldHeader, newHeader fs.FileHeader) error {
	return nil
}

//
func (d *Drive) CreateDir(ctx context.Context, header fs.DirHeader) error {
	return nil
}

func (d *Drive) ReadDir(ctx context.Context, header fs.DirHeader) (fs.DirHeader, error) {
	return fs.DirHeader{}, nil
}

func (d *Drive) DeleteDir(ctx context.Context, header fs.DirHeader) error {
	return nil
}

func (d *Drive) RenameDir(ctx context.Context, oldHeader, newHeader fs.DirHeader) error {
	return nil
}

// useless?
func (d *Drive) AddContext(ctx context.Context) {

}

func createFile(srv *drive.Service, ctx context.Context, parentID string, h fs.FileHeader, src io.Reader) error {

	file := &drive.File{
		OriginalFilename: filepath.Base(h.Name), // sddsf/sdfasdfasdf/jdfi -> jdfi
		ModifiedTime:     strconv.FormatUint(h.ModTime, 10),
		MimeType:         "application/octet-stream", // binary
		IsAppAuthorized:  true,
		Parents:          []string{parentID},
		FileExtension:    ".bin",
	}

	// chuck size of media upload should be equal or larger to encryption chuck size / buffer.
	// googleapi.DefaultUploadChunkSize is 10MB, can be any mulpiple of 256kB.
	// TODO(liamvdv): look into Media()s googleapi.MediaOptions
	// googleapi.ContentType
	res, err := srv.Files.Create(file).Media(src, googleapi.ContentType("application/octet-stream")).Context(ctx).Do()
	return handleDoError(res, err.(*googleapi.Error)) // TODO(liamvdv): does a type conversion on nil break?
}

// Do executes the "drive.files.insert" call. Exactly one of *File or error will be non-nil.
// Any non-2xx status code is an error. Response headers are in either *File.ServerResponse.Header
// or (if a response was returned at all) in error.(*googleapi.Error).Header.
// Use googleapi.IsNotModified to check whether the returned error was because http.StatusNotModified was returned.
func handleDoError(file *drive.File, err *googleapi.Error) error {
	// TODO(liamvdv): we have access to headers, dunno how to handle anything.
	var code int
	if file == nil {
		code = err.Code
	} else {
		code = file.ServerResponse.HTTPStatusCode
	}
	if code == http.StatusNotModified {
		return nil
	}
	return nil
}
